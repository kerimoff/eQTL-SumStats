params.chromosomes = ['1', '2', '3', '4', '5', '6', '7', '8', '9', '10', '11', '12', '13', '14', '15', '16', '17', '18', '19', '20', '21', '22', 'X']
// params.chromosomes = ['1', '2', '3', '4', '5', '6', '7', '8', '9', '10', '11', '12', '13', '14', '15', '16', '17', '18', '19', '20', '21', '22']
// params.chromosomes = ['7', '8', '9']
// params.quant_methods = ['ge', 'microarray', 'exon', 'tx', 'txrev']
// params.quant_methods = ['microarray']
params.quant_methods = ['ge']

// ---------------- runtime args ----------------------

/* The meta_table must be a tsv e.g. example_metadata.tsv
   It must contain the following headers:
   'study', 'qtl_group', 'quant_method', 'tissue_ontology_id','filename'
   where 'filename' stores the basenames of the input tsvs
*/
params.meta_table = '/gpfs/space/home/kerimov/HDF5_data_conv/loading/data/metadata_gtex.tsv'

// The directory for the input tsvs:
params.tsv_in = '/gpfs/space/home/kerimov/HDF5_data_conv/loading/data/eQTLCat_GTEx_V5_1/'

// The directories where the HDF5 are published (by study, by chromsome)
params.hdf5_study_dir = '/gpfs/space/projects/GTEx/HDF5_V5_1/bystudy/'
params.hdf5_chrom_dir = '/gpfs/space/projects/GTEx/HDF5_V5_1/bychr/'


// For LSF execution the exitReadTimeout may need increasing to
// something much larger than you'd expect
//executor {
//  name = 'lsf'
//  queueSize = 100
//  exitReadTimeout = '1200 sec'
//}

singularity {
  enabled = true
  autoMounts = true
  cacheDir = "$baseDir/singularity_img/"
}

executor {
    name = 'slurm'
    queueSize = 300
    submitRateLimit = 1
}

process {
  executor = 'slurm'
  queue = 'amd'
  beforeScript = 'module load singularity/3.5.3'
}

process {
  cpus = { check_max( 1, 'cpus' ) }
  memory = { check_max( 8.GB * task.attempt, 'memory' ) }
  time = { check_max( 30.h * task.attempt, 'time' ) }

  // errorStrategy = { task.exitStatus in [1,143,137,104,134,139,255] ? 'retry' : 'terminate' }
  errorStrategy = { task.exitStatus in [1] ? 'terminate' : 'retry' }
  maxRetries = 3
  maxErrors = '-1'
}

params {
  // Defaults only, expecting to be overwritten
  max_memory = 128.GB
  max_cpus = 16
  max_time = 192.h
}

// Function to ensure that resource requirements don't go beyond
// a maximum limit
def check_max(obj, type) {
  if(type == 'memory'){
    try {
      if(obj.compareTo(params.max_memory as nextflow.util.MemoryUnit) == 1)
        return params.max_memory as nextflow.util.MemoryUnit
      else
        return obj
    } catch (all) {
      println "   ### ERROR ###   Max memory '${params.max_memory}' is not valid! Using default value: $obj"
      return obj
    }
  } else if(type == 'time'){
    try {
      if(obj.compareTo(params.max_time as nextflow.util.Duration) == 1)
        return params.max_time as nextflow.util.Duration
      else
        return obj
    } catch (all) {
      println "   ### ERROR ###   Max time '${params.max_time}' is not valid! Using default value: $obj"
      return obj
    }
  } else if(type == 'cpus'){
    try {
      return Math.min( obj, params.max_cpus as int )
    } catch (all) {
      println "   ### ERROR ###   Max cpus '${params.max_cpus}' is not valid! Using default value: $obj"
      return obj
    }
  }
}